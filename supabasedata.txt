-- ============================================
-- StudyBuddy Supabase Database Migration
-- Copy and paste this into Supabase SQL Editor
-- ============================================

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================
-- 1. PROFILES TABLE (extends auth.users)
-- ============================================

CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT,
  email TEXT,
  has_seen_intro BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX profiles_email_idx ON profiles(email);

-- Trigger to auto-create profile when user signs up
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, name)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'name', NEW.raw_user_meta_data->>'full_name')
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user();

-- RLS Policies for profiles
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own profile"
  ON profiles FOR SELECT
  TO authenticated
  USING (auth.uid() = id);

CREATE POLICY "Users can update own profile"
  ON profiles FOR UPDATE
  TO authenticated
  USING (auth.uid() = id);

-- ============================================
-- 2. NOTES TABLE
-- ============================================

CREATE TABLE notes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  title TEXT NOT NULL CHECK (char_length(title) > 0),
  content TEXT NOT NULL DEFAULT '',
  category TEXT,
  tags TEXT[],
  color TEXT,
  grade INTEGER CHECK (grade >= 0 AND grade <= 100),
  feedback TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX notes_user_id_idx ON notes(user_id);
CREATE INDEX notes_user_updated_idx ON notes(user_id, updated_at DESC);
CREATE INDEX notes_category_idx ON notes(category);

-- Full-text search setup
ALTER TABLE notes ADD COLUMN content_search TSVECTOR
  GENERATED ALWAYS AS (to_tsvector('english', coalesce(title, '') || ' ' || coalesce(content, ''))) STORED;
CREATE INDEX notes_content_search_idx ON notes USING GIN(content_search);

-- RLS Policies for notes
ALTER TABLE notes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own notes"
  ON notes FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "Users can read shared notes"
  ON notes FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM note_shares
      WHERE note_shares.note_id = notes.id
      AND note_shares.shared_with_id = auth.uid()
    )
  );

CREATE POLICY "Users can create own notes"
  ON notes FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own notes"
  ON notes FOR UPDATE
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own notes"
  ON notes FOR DELETE
  TO authenticated
  USING (auth.uid() = user_id);

-- ============================================
-- 3. NOTE_VERSIONS TABLE
-- ============================================

CREATE TABLE note_versions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  note_id UUID NOT NULL REFERENCES notes(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX note_versions_note_id_idx ON note_versions(note_id, created_at DESC);
CREATE INDEX note_versions_user_id_idx ON note_versions(user_id);

-- RLS Policies
ALTER TABLE note_versions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own note versions"
  ON note_versions FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create note versions"
  ON note_versions FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

-- ============================================
-- 4. NOTE_SHARES TABLE
-- ============================================

CREATE TABLE note_shares (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  note_id UUID NOT NULL REFERENCES notes(id) ON DELETE CASCADE,
  owner_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  shared_with_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('editor', 'viewer')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(note_id, shared_with_id)
);

CREATE INDEX note_shares_note_id_idx ON note_shares(note_id);
CREATE INDEX note_shares_shared_with_idx ON note_shares(shared_with_id);
CREATE INDEX note_shares_note_user_idx ON note_shares(note_id, shared_with_id);

-- RLS Policies
ALTER TABLE note_shares ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Owners can manage shares"
  ON note_shares FOR ALL
  TO authenticated
  USING (auth.uid() = owner_id);

CREATE POLICY "Shared users can read shares"
  ON note_shares FOR SELECT
  TO authenticated
  USING (auth.uid() = shared_with_id);

-- ============================================
-- 5. COMMENTS TABLE
-- ============================================

CREATE TABLE comments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  note_id UUID NOT NULL REFERENCES notes(id) ON DELETE CASCADE,
  author_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  text TEXT NOT NULL CHECK (char_length(text) > 0),
  selection_start INTEGER,
  selection_end INTEGER,
  selection_text TEXT,
  resolved BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX comments_note_id_idx ON comments(note_id, created_at DESC);
CREATE INDEX comments_author_id_idx ON comments(author_id);

-- RLS Policies
ALTER TABLE comments ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read comments on accessible notes"
  ON comments FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM notes
      WHERE notes.id = comments.note_id
      AND (notes.user_id = auth.uid() OR EXISTS (
        SELECT 1 FROM note_shares
        WHERE note_shares.note_id = notes.id
        AND note_shares.shared_with_id = auth.uid()
      ))
    )
  );

CREATE POLICY "Users can create comments on accessible notes"
  ON comments FOR INSERT
  TO authenticated
  WITH CHECK (
    auth.uid() = author_id AND
    EXISTS (
      SELECT 1 FROM notes
      WHERE notes.id = comments.note_id
      AND (notes.user_id = auth.uid() OR EXISTS (
        SELECT 1 FROM note_shares
        WHERE note_shares.note_id = notes.id
        AND note_shares.shared_with_id = auth.uid()
      ))
    )
  );

CREATE POLICY "Users can update own comments"
  ON comments FOR UPDATE
  TO authenticated
  USING (auth.uid() = author_id);

CREATE POLICY "Users can delete own comments"
  ON comments FOR DELETE
  TO authenticated
  USING (auth.uid() = author_id);

-- ============================================
-- 6. PRESENCE TABLE
-- ============================================

CREATE TABLE presence (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  note_id UUID NOT NULL REFERENCES notes(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  cursor INTEGER,
  selection_start INTEGER,
  selection_end INTEGER,
  last_seen TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(note_id, user_id)
);

CREATE INDEX presence_note_id_idx ON presence(note_id);
CREATE INDEX presence_note_user_idx ON presence(note_id, user_id);

-- Auto-cleanup old presence (older than 5 minutes)
CREATE OR REPLACE FUNCTION cleanup_old_presence()
RETURNS void AS $$
BEGIN
  DELETE FROM presence WHERE last_seen < NOW() - INTERVAL '5 minutes';
END;
$$ LANGUAGE plpgsql;

-- RLS Policies
ALTER TABLE presence ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read presence on accessible notes"
  ON presence FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM notes
      WHERE notes.id = presence.note_id
      AND (notes.user_id = auth.uid() OR EXISTS (
        SELECT 1 FROM note_shares
        WHERE note_shares.note_id = notes.id
        AND note_shares.shared_with_id = auth.uid()
      ))
    )
  );

CREATE POLICY "Users can insert own presence"
  ON presence FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own presence"
  ON presence FOR UPDATE
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own presence"
  ON presence FOR DELETE
  TO authenticated
  USING (auth.uid() = user_id);

-- ============================================
-- 7. REMINDERS TABLE
-- ============================================

CREATE TABLE reminders (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  note_id UUID REFERENCES notes(id) ON DELETE CASCADE,
  title TEXT NOT NULL CHECK (char_length(title) > 0),
  description TEXT,
  when TIMESTAMPTZ NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('study', 'review', 'exam', 'deadline')),
  completed BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX reminders_user_id_idx ON reminders(user_id);
CREATE INDEX reminders_note_id_idx ON reminders(note_id);
CREATE INDEX reminders_when_idx ON reminders(when);
CREATE INDEX reminders_user_when_idx ON reminders(user_id, when);

-- RLS Policies
ALTER TABLE reminders ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage own reminders"
  ON reminders FOR ALL
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- ============================================
-- 8. FLASHCARD_SETS TABLE
-- ============================================

CREATE TABLE flashcard_sets (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  note_id UUID REFERENCES notes(id) ON DELETE CASCADE,
  subject TEXT NOT NULL,
  cards JSONB NOT NULL DEFAULT '[]',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX flashcard_sets_user_id_idx ON flashcard_sets(user_id);
CREATE INDEX flashcard_sets_note_id_idx ON flashcard_sets(note_id);

-- RLS Policies
ALTER TABLE flashcard_sets ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage own flashcard sets"
  ON flashcard_sets FOR ALL
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- ============================================
-- 9. FLASHCARD_SESSIONS TABLE
-- ============================================

CREATE TABLE flashcard_sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  set_id UUID NOT NULL REFERENCES flashcard_sets(id) ON DELETE CASCADE,
  card_index INTEGER NOT NULL,
  response TEXT NOT NULL CHECK (response IN ('again', 'hard', 'good', 'easy')),
  timestamp TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX flashcard_sessions_user_id_idx ON flashcard_sessions(user_id);
CREATE INDEX flashcard_sessions_set_id_idx ON flashcard_sessions(set_id);

-- RLS Policies
ALTER TABLE flashcard_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage own flashcard sessions"
  ON flashcard_sessions FOR ALL
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- ============================================
-- 10. QUIZZES TABLE
-- ============================================

CREATE TABLE quizzes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  note_id UUID REFERENCES notes(id) ON DELETE CASCADE,
  subject TEXT NOT NULL,
  questions JSONB NOT NULL DEFAULT '[]',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX quizzes_user_id_idx ON quizzes(user_id);
CREATE INDEX quizzes_note_id_idx ON quizzes(note_id);

-- RLS Policies
ALTER TABLE quizzes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage own quizzes"
  ON quizzes FOR ALL
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- ============================================
-- 11. QUIZ_SESSIONS TABLE
-- ============================================

CREATE TABLE quiz_sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  quiz_id UUID NOT NULL REFERENCES quizzes(id) ON DELETE CASCADE,
  answers JSONB NOT NULL DEFAULT '[]',
  score INTEGER NOT NULL,
  total INTEGER NOT NULL,
  timestamp TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX quiz_sessions_user_id_idx ON quiz_sessions(user_id);
CREATE INDEX quiz_sessions_quiz_id_idx ON quiz_sessions(quiz_id);

-- RLS Policies
ALTER TABLE quiz_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage own quiz sessions"
  ON quiz_sessions FOR ALL
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- ============================================
-- 12. STUDY_PLANS TABLE
-- ============================================

CREATE TABLE study_plans (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  title TEXT NOT NULL CHECK (char_length(title) > 0),
  description TEXT,
  subject TEXT,
  start_date TIMESTAMPTZ,
  end_date TIMESTAMPTZ,
  tasks JSONB DEFAULT '[]',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX study_plans_user_id_idx ON study_plans(user_id);
CREATE INDEX study_plans_subject_idx ON study_plans(subject);

-- RLS Policies
ALTER TABLE study_plans ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage own study plans"
  ON study_plans FOR ALL
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- ============================================
-- 13. PROGRESS_LOGS TABLE
-- ============================================

CREATE TABLE progress_logs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  date DATE NOT NULL,
  minutes INTEGER DEFAULT 0,
  notes_created INTEGER DEFAULT 0,
  notes_updated INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, date)
);

CREATE INDEX progress_logs_user_id_idx ON progress_logs(user_id);
CREATE INDEX progress_logs_user_date_idx ON progress_logs(user_id, date DESC);

-- RLS Policies
ALTER TABLE progress_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage own progress logs"
  ON progress_logs FOR ALL
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- ============================================
-- 14. FILES TABLE
-- ============================================

CREATE TABLE files (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  note_id UUID REFERENCES notes(id) ON DELETE SET NULL,
  name TEXT NOT NULL,
  type TEXT NOT NULL,
  size BIGINT NOT NULL,
  storage_path TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  uploaded_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX files_user_id_idx ON files(user_id);
CREATE INDEX files_note_id_idx ON files(note_id);

-- RLS Policies
ALTER TABLE files ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage own files"
  ON files FOR ALL
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- ============================================
-- 15. USER_STATS TABLE
-- ============================================

CREATE TABLE user_stats (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE UNIQUE,
  has_seen_intro BOOLEAN DEFAULT false,
  total_study_minutes INTEGER DEFAULT 0,
  notes_created INTEGER DEFAULT 0,
  plans_completed INTEGER DEFAULT 0,
  last_active_date DATE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX user_stats_user_id_idx ON user_stats(user_id);

-- RLS Policies
ALTER TABLE user_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage own stats"
  ON user_stats FOR ALL
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- ============================================
-- 16. MENTOR_CHATS TABLE
-- ============================================

CREATE TABLE mentor_chats (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  note_id UUID REFERENCES notes(id) ON DELETE CASCADE,
  message TEXT NOT NULL,
  response TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX mentor_chats_user_id_idx ON mentor_chats(user_id);
CREATE INDEX mentor_chats_note_id_idx ON mentor_chats(note_id);
CREATE INDEX mentor_chats_created_idx ON mentor_chats(created_at DESC);

-- RLS Policies
ALTER TABLE mentor_chats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage own mentor chats"
  ON mentor_chats FOR ALL
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- ============================================
-- 17. EXAM_SETS TABLE
-- ============================================

CREATE TABLE exam_sets (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  subject TEXT NOT NULL,
  questions JSONB NOT NULL DEFAULT '[]',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX exam_sets_user_id_idx ON exam_sets(user_id);

-- RLS Policies
ALTER TABLE exam_sets ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage own exam sets"
  ON exam_sets FOR ALL
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- ============================================
-- 18. PLAN_NOTES TABLE
-- ============================================

CREATE TABLE plan_notes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  plan_id UUID NOT NULL REFERENCES study_plans(id) ON DELETE CASCADE,
  note_id UUID NOT NULL REFERENCES notes(id) ON DELETE CASCADE,
  completed BOOLEAN DEFAULT false,
  added_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(plan_id, note_id)
);

CREATE INDEX plan_notes_plan_id_idx ON plan_notes(plan_id);
CREATE INDEX plan_notes_note_id_idx ON plan_notes(note_id);
CREATE INDEX plan_notes_plan_note_idx ON plan_notes(plan_id, note_id);

-- RLS Policies
ALTER TABLE plan_notes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage plan notes for own plans"
  ON plan_notes FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM study_plans
      WHERE study_plans.id = plan_notes.plan_id
      AND study_plans.user_id = auth.uid()
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM study_plans
      WHERE study_plans.id = plan_notes.plan_id
      AND study_plans.user_id = auth.uid()
    )
  );

-- ============================================
-- ENABLE REALTIME FOR COLLABORATION
-- ============================================

ALTER PUBLICATION supabase_realtime ADD TABLE notes;
ALTER PUBLICATION supabase_realtime ADD TABLE presence;
ALTER PUBLICATION supabase_realtime ADD TABLE comments;
ALTER PUBLICATION supabase_realtime ADD TABLE note_shares;

-- ============================================
-- STORAGE BUCKET SETUP
-- ============================================

-- Create user-files bucket
INSERT INTO storage.buckets (id, name, public)
VALUES ('user-files', 'user-files', false);

-- Storage policy: Users can upload to their own folder
CREATE POLICY "Users can upload files to own folder"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (
  bucket_id = 'user-files' AND
  (storage.foldername(name))[1] = auth.uid()::text
);

-- Storage policy: Users can read their own files
CREATE POLICY "Users can read own files"
ON storage.objects FOR SELECT
TO authenticated
USING (
  bucket_id = 'user-files' AND
  (storage.foldername(name))[1] = auth.uid()::text
);

-- Storage policy: Users can delete their own files
CREATE POLICY "Users can delete own files"
ON storage.objects FOR DELETE
TO authenticated
USING (
  bucket_id = 'user-files' AND
  (storage.foldername(name))[1] = auth.uid()::text
);

-- ============================================
-- MIGRATION COMPLETE
-- ============================================
-- After running this SQL:
-- 1. Enable Google OAuth in Supabase Auth settings
-- 2. Deploy Edge Functions (see supabase/functions/)
-- 3. Set OPENAI_API_KEY secret for Edge Functions
-- 4. Update frontend .env with Supabase URL and keys
-- ============================================
